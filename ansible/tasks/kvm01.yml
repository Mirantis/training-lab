# https://docs.mirantis.com/mcp/master/mcp-deployment-guide/deploy-mcp-drivetrain/automated-deployment-of-mcp-drivetrain.html

- name: Install packages related to kvm01
  apt:
    name: "{{ item }}"
    update_cache: yes
  loop: "{{ kvm01_packages }}"

- name: Add vncserver to the systemd
  template:
    src: templates/vncserver-service.j2
    dest: /etc/systemd/system/vncserver@.service
  notify: reload systemd

- name: Create /home/{{ default_student_account_name }}/.vnc directory
  file:
    path: /home/{{ default_student_account_name }}/.vnc
    state: directory
    mode: 0700

- name: Set VNC password in /home/{{ default_student_account_name }}/.vnc/passwd
  shell: umask 077; echo "{{ student_password }}" | vncpasswd -f > /home/{{ default_student_account_name }}/.vnc/passwd
  args:
    creates: /home/{{ default_student_account_name }}/.vnc/passwd
  changed_when: false

- name: Add xstartup to student account /home/{{ default_student_account_name }}/.vnc/xstartup
  template:
    src: templates/vnc-xstartup.j2
    dest: /home/{{ default_student_account_name }}/.vnc/xstartup
    mode: 0755

- name: Change owner of /home/{{ default_student_account_name }}/.vnc to {{ default_student_account_name }}:{{ default_student_account_name }}
  file:
    path: /home/{{ default_student_account_name }}/.vnc
    owner: "{{ default_student_account_name }}"
    group: "{{ default_student_account_name }}"
    recurse: yes

- name: Create certificate for novnc
  command: openssl req -x509 -nodes -newkey rsa:2048 -keyout /etc/ssl/novnc.pem -out /etc/ssl/novnc.pem -days 365 -subj "/C=CZ/ST=Czech/L=Prague/O=Mirantis/CN={{ domain }}"
  args:
    creates: /etc/ssl/novnc.pem

- name: Add systemd service for novnc
  template:
    src: templates/novnc.service.j2
    dest: /etc/systemd/system/novnc.service
  notify: reload systemd

- name: Enable vncserver + https acces on ufw
  ufw:
    rule: allow
    port: "{{ item }}"
    proto: tcp
  loop:
    - 5901
    - 443

- name: Change ufw settings /etc/default/ufw
  lineinfile:
    dest: /etc/default/ufw
    regexp: "{{ item.regexp }}"
    line: "{{ item.line }}"
  loop:
    - { regexp: '^DEFAULT_FORWARD_POLICY', line: 'DEFAULT_FORWARD_POLICY="ACCEPT"' }
    - { regexp: '^DEFAULT_INPUT_POLICY', line: 'DEFAULT_INPUT_POLICY="ACCEPT"' }
  notify: restart ufw

- name: Add port forwarding for Jenkins and MAAS to be accessible form Public IP
  blockinfile:
    path: /etc/ufw/before.rules
    insertbefore: Don't delete these required lines, otherwise there will be errors
    block: |
      # nat Table rules
      *nat
      :POSTROUTING ACCEPT [0:0]
      :PREROUTING ACCEPT [0:0]

      # Masquarade traffic for {{ networks.deploy_network.subnet_netmask }} going out of {{ ansible_default_ipv4.interface }}
      -A POSTROUTING -s {{ networks.deploy_network.subnet_netmask }} -o {{ ansible_default_ipv4.interface }} -j MASQUERADE

      # Add port forwarding
      # Jenkins: http://{{ inventory_hostname }}:8081 -> http://{{ salt_master_ip }}:8081
      -A PREROUTING -i {{ ansible_default_ipv4.interface }} -d {{ ansible_default_ipv4.address }} -p tcp --dport 8081 -j DNAT --to-destination {{ salt_master_ip }}:8081
      # MAAS: http://{{ inventory_hostname }}/MAAS -> http://{{ salt_master_ip }}/MAAS
      -A PREROUTING -i {{ ansible_default_ipv4.interface }} -d {{ ansible_default_ipv4.address }} -p tcp --dport 80 -j DNAT --to-destination {{ salt_master_ip }}:80

      COMMIT
  notify:
    - restart ufw

- name: Run all notify sections
  meta: flush_handlers

- name: Enable UFW
  ufw:
    state: enabled

- name: Start vncserver when booting
  service:
    name: vncserver@1.service
    enabled: yes
    state: started

- name: Start novnc when booting
  service:
    name: novnc
    enabled: yes
    state: started

- name: Create directory /var/lib/libvirt/images/cfg01/
  file:
    path: /var/lib/libvirt/images/cfg01
    state: directory

- name: Download VM image
  get_url:
    url: "{{ cfg01_image_url }}"
    dest: /var/lib/libvirt/images/cfg01/cfg01-day01.qcow2

- name: Copy the original cfg01-day01 to {{ cfg01_vm_source_disk }}
  copy:
    src: /var/lib/libvirt/images/cfg01/cfg01-day01.qcow2
    dest: "{{ cfg01_vm_source_disk }}"
    force: no
    remote_src: yes

- name: Clone repository with salt-model ({{ salt_model_git_repository }})
  git:
    repo: "{{ salt_model_git_repository }}"
    dest: /root/model
    version: latest

- name: Clone repository with mk-pipelines
  git:
    repo: "{{ mk_pipelines_git_repository }}"
    dest: /root/mk-pipelines
    version: latest

- name:  Clone repository with pipeline-library
  git:
    repo: "{{ pipeline_library_git_repository }}"
    dest: /root/pipeline-library
    version: latest

- name: Download create-config-drive script ({{ create_config_drive_script_url }})
  get_url:
    url: "{{ create_config_drive_script_url }}"
    dest: /root/create-config-drive
    mode: 0755

- name: Download master_config script ({{ master_config_script_url }})
  get_url:
    url: "{{ master_config_script_url }}"
    dest: /root/user_data.sh
    mode: 0755

- name: Change the params in /root/user_data.sh "{{ master_config_script_url }}"
  lineinfile:
    path: /root/user_data.sh
    regexp: "{{ item.regexp }}"
    line: "{{ item.line }}"
  loop:
    - { regexp: '^export SALT_MASTER_DEPLOY_IP', line: 'export SALT_MASTER_DEPLOY_IP={{ salt_master_ip }}' }
    - { regexp: '^export SALT_MASTER_MINION_ID', line: 'export SALT_MASTER_MINION_ID=cfg01.{{ domain }}' }
    - { regexp: '^export DEPLOY_NETWORK_GW', line: 'export DEPLOY_NETWORK_GW={{ networks.deploy_network.gateway }}' }
    - { regexp: '^export DEPLOY_NETWORK_NETMASK', line: 'export DEPLOY_NETWORK_NETMASK={{ networks.deploy_network.netmask }}' }
    - { regexp: '^export PIPELINES_FROM_ISO', line: 'export PIPELINES_FROM_ISO=false' }
    - { regexp: '^export MCP_VERSION', line: 'export MCP_VERSION="{{ mcp_release }}"' }

- name: Create the iso from salt model
  command: /root/create-config-drive -u /root/user_data.sh -h cfg01 --model /root/model --mk-pipelines /root/mk-pipelines --pipeline-library /root/pipeline-library {{ cfg01_vm_config_disk }}
  args:
    chdir: /root
    creates: "{{ cfg01_vm_config_disk }}"

- name: Download define-vm script ({{ define_vm_script_url }})
  get_url:
    url: "{{ define_vm_script_url }}"
    dest: /root/define-vm.sh
    mode: 0755

- name: Define the cfg01 VM
  command: /root/define-vm.sh
  args:
    chdir: /root
    creates: "/root/{{ cfg01_vm_name }}-vm.xml"
  environment:
    VM_NAME: "{{ cfg01_vm_name }}"
    VM_SOURCE_DISK: "{{ cfg01_vm_source_disk }}"
    VM_CONFIG_DISK: "{{ cfg01_vm_config_disk }}"
    VM_MGM_BRIDGE_NAME: "{{ cfg01_vm_mgm_bridge_name }}"
    VM_CTL_BRIDGE_NAME: "{{ cfg01_vm_ctl_bridge_name }}"
    VM_MEM_KB: "{{ cfg01_vm_mem_kb }}"
    VM_CPUS: "{{ cfg01_vm_cpus }}"
  register: define_vm_output
  changed_when: define_vm_output.stdout is search('defined from')

- name: Start {{ cfg01_vm_name }}
  virt:
    name: cfg01.{{ domain }}
    state: running
